import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinColumn,
  JoinTable,
  ManyToMany as ManyToManyTypeOrm,
  ManyToOne,
  ObjectIdColumn,
  OneToMany,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
  VersionColumn
} from 'typeorm'
import { Collection } from 'fireorm'
import { GraphQLID } from 'graphql'
import { ApiProperty, HideField, ObjectType, ApiHideProperty } from '../types'
import { Primitives } from '../../types'
import { applyDecorators } from '../Nestjs/applyDecorators'
import { Field } from '../Nestjs/types/decorators/field.decorator'

interface PropertyInterface {
  required?: boolean
  unique?: boolean
  hidden?: boolean
}

interface EnumProperty {
  enum: any[]
  default?: Primitives
}

export declare type ObjectTypeI<T> = new () => T

interface ManyToManyInterface<T> {
  entity: (type?: any) => ObjectTypeI<T>
  joinTableName: string
  foreignKey: string
  inverseForeignKey: string
}

interface BelongsToInterface<T> {
  entity: (type?: any) => ObjectTypeI<T>
  inverse: string | ((object: T) => any)
  pivotColumnName: string
}

interface hasManyInterface<T> {
  entity: (type?: any) => ObjectTypeI<T>
  inverse: string | ((object: T) => any)
}

export const Decorators = (() => {
  /**
   *
   * @param spec
   */
  const id = (isMongo?: boolean): PropertyDecorator => {
    isMongo = false

    if (process.env.MAIN_DATABASE_TYPE === 'mongodb' || isMongo) {
      return applyDecorators(
        ObjectIdColumn() as PropertyDecorator,
        PrimaryGeneratedColumn('uuid') as PropertyDecorator,
        ApiProperty(),
        Field(() => GraphQLID),
        Column() as PropertyDecorator
        // AutoGeneratedHashKey()
      )
    }

    return applyDecorators(
      PrimaryGeneratedColumn('uuid') as PropertyDecorator,
      ApiProperty(),
      Field(() => GraphQLID),
      Column() as PropertyDecorator
      // AutoGeneratedHashKey()
    )
  }
  /**
   *
   * @param name
   */
  const entity = (name: string): ClassDecorator => {
    // TODO implement pascal case for this
    const PascalCase = name
    return applyDecorators(
      Entity({ name: PascalCase }),
      ObjectType(),
      Collection(PascalCase) as ClassDecorator
    )
  }
  /**
   *
   * @param params
   */
  const property = (params?: PropertyInterface): PropertyDecorator => {
    if (params && params.hidden) {
      return applyDecorators(
        HideField(),
        Column({
          select: false,
          nullable: !params.required
        }) as PropertyDecorator,
        ApiProperty({
          nullable: !params.required,
          required: !!params.required
        }),
        ApiHideProperty()
      )
    }
    return applyDecorators(
      Column({
        nullable: !params.required
      }) as PropertyDecorator,
      ApiProperty({
        nullable: !params.required,
        required: !!params.required
      }),
      Field()
    )
  }
  /**
   *
   * @param e
   */
  const embed = (e: any): PropertyDecorator =>
    applyDecorators(
      Column(type => e) as PropertyDecorator,
      ApiProperty({ type: e })
      // Attribute({ memberType: dynamoEmbed(e) })
    )
  /**
   *
   * @param e
   */
  const embedArray = (e: any, params?: PropertyInterface): PropertyDecorator =>
    applyDecorators(
      Column(type => e) as PropertyDecorator,
      ApiProperty({
        isArray: true,
        type: e,
        nullable: !params.required,
        required: !!params.required
      })
    )
  /**
   *
   * @param params
   */
  const array = (e: any, params?: PropertyInterface): PropertyDecorator =>
    applyDecorators(
      Column({
        type: 'simple-array',
        nullable: !params?.required
      }) as PropertyDecorator,
      ApiProperty({
        type: [e],
        nullable: !params?.required,
        required: !!params?.required
      })
    )
  /**
   *
   * @param e
   * @param params
   */
  const Enum = (
    e: EnumProperty,
    params?: PropertyInterface
  ): PropertyDecorator =>
    applyDecorators(
      // Attribute(),
      Column({
        type: 'enum',
        enum: e.enum,
        default: e.default,
        nullable: !params.required
      }) as PropertyDecorator,
      ApiProperty({
        enum: e.enum,
        default: e.default,
        nullable: !params.required,
        required: !!params.required
      })
    )
  /**
   *
   * @param e
   */
  const created = (e?: any): PropertyDecorator =>
    applyDecorators(CreateDateColumn(), ApiProperty())
  /**
   *
   * @param e
   */
  const updated = (e?: any): PropertyDecorator =>
    applyDecorators(UpdateDateColumn(), ApiProperty())
  /**
   *
   * @param e
   */
  const deleted = (e?: any): PropertyDecorator =>
    applyDecorators(DeleteDateColumn(), ApiProperty())
  /**
   *
   * @param e
   */
  const version = (e?: any): PropertyDecorator =>
    applyDecorators(VersionColumn(), ApiProperty())

  function belongsToMany<T>({
    // tslint:disable-next-line: no-shadowed-variable
    entity,
    joinTableName,
    foreignKey,
    inverseForeignKey
  }: ManyToManyInterface<T>): PropertyDecorator {
    return applyDecorators(
      ManyToManyTypeOrm(entity),
      JoinTable({
        name: joinTableName,
        joinColumns: [{ name: foreignKey }],
        inverseJoinColumns: [{ name: inverseForeignKey }]
      })
    )
  }

  function belongsTo<T>({
    // tslint:disable-next-line: no-shadowed-variable
    entity,
    inverse,
    pivotColumnName
  }: BelongsToInterface<T>): PropertyDecorator {
    return applyDecorators(
      ManyToOne(entity, inverse),
      JoinColumn({ name: pivotColumnName })
    )
  }

  function hasMany<T>({
    // tslint:disable-next-line: no-shadowed-variable
    entity,
    inverse
  }: hasManyInterface<T>): PropertyDecorator {
    return applyDecorators(OneToMany(entity, inverse))
  }

  return Object.freeze({
    id,
    entity,
    property,
    embed,
    embedArray,
    array,
    Enum,
    created,
    updated,
    version,
    deleted,
    belongsToMany,
    hasMany,
    belongsTo
  })
})()
