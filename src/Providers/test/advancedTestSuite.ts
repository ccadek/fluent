import {
  Entity,
  Column,
  PrimaryGeneratedColumn,
  Index,
  ObjectIdColumn
} from 'typeorm'
import { Field, ID, ObjectType } from '@nestjs/graphql'
import { ApiProperty } from '@nestjs/swagger'
import { Collection } from 'fireorm'
import {
  Attribute,
  AutoGeneratedHashKey,
  RangeKey,
  Table,
  VersionAttribute,
  embed
} from 'nestjs-typed-dynamodb'

export class DataModel {
  created?: string
  nestedTest: { a: number[]; b: { c: boolean; d: number[] }; c: number }
  order?: number
  test: boolean
}

// tslint:disable-next-line: max-classes-per-file
export class FurtherNested {
  @Column()
  @ApiProperty()
  @Attribute()
  c: boolean

  @Attribute()
  @Column({ type: 'simple-array', nullable: false })
  @ApiProperty({ type: [Number], nullable: false, required: true })
  d: number[]
}

// tslint:disable-next-line: max-classes-per-file
export class Nested {
  @PrimaryGeneratedColumn('uuid')
  @ObjectIdColumn()
  @ApiProperty()
  @AutoGeneratedHashKey()
  @Field(() => ID)
  id: string

  @Attribute()
  @Column({ type: 'simple-array', nullable: false })
  @ApiProperty({ type: [Number], nullable: false, required: true })
  a: number[]

  @Column()
  @ApiProperty()
  @Attribute()
  c: number

  @Column(type => FurtherNested)
  @ApiProperty({ type: FurtherNested })
  @Attribute({ memberType: embed(FurtherNested) })
  b?: FurtherNested
}

// tslint:disable-next-line: max-classes-per-file
@Entity()
@ObjectType()
@Collection('numbers')
export class TypeORMDataModel {
  @Column()
  @Index()
  @ApiProperty()
  @Attribute()
  created?: string

  @Column(type => Nested)
  @ApiProperty({ type: Nested })
  @Attribute({ memberType: embed(Nested) })
  nestedTest?: Nested

  @Column()
  @ApiProperty()
  @Attribute()
  order?: number

  @Column()
  @ApiProperty()
  @Attribute()
  test: boolean
}

export const advancedTestSuite = Model => {
  /**
   *
   */
  const insertTestData = async () => {
    await Model.insert({
      created: '2018-12-03',
      nestedTest: {
        a: [6, 5, 4],
        b: { c: true, d: [2, 1, 0] },
        c: 4
      },
      order: 1,
      test: true
    })
    await Model.insert({
      created: '2017-12-03',
      nestedTest: {
        a: [3, 2, 1],
        b: { c: true, d: [1, 1, 0] },
        c: 3
      },
      order: 2,
      test: false
    })
    await Model.insert({
      created: '2016-12-03',
      nestedTest: {
        a: [0, -1, -2],
        b: { c: true, d: [0, 1, 0] },
        c: 2
      },
      order: 3,
      test: false
    })
  }

  it('Should get paginated data', async () => {
    await insertTestData()
    const data = await Model.paginate({ page: 1, perPage: 10 })
    console.log(data)
    expect(true).toBe(true)
  })

  /*
  it('Should get local data', async () => {
    await insertTestData()
    const data = await Model.all()
    expect(Array.isArray(data)).toBe(true)
    expect(data[0].nestedTest.a[0]).toBe(6)
  })

  it('pluck() should return a single array', async () => {
    await insertTestData()
    const data = await Model.pluck(Model._keys.test)
    expect(data[0]).toBe(true)
  })

  it('orderBy() should order results desc', async () => {
    await insertTestData()
    const forms = await Model.select(
      Model._keys.test,
      Model._keys.nestedTest.b.c,
      Model._keys.order
    )
      .orderBy(Model._keys.order, 'desc')
      .get()
    expect(forms[0].order).toBe(3)
    expect(forms[0].nestedTest.b.c).toBe(true)
  })

  it('orderBy() should order results asc', async () => {
    await insertTestData()
    const forms = await Model.select(
      Model._keys.test,
      Model._keys.nestedTest.b.c,
      Model._keys.order
    )
      .orderBy(Model._keys.order, 'asc')
      .get()

    expect(forms[0].order).toBe(1)
  })

  it('orderBy() should order by Dates with Select()', async () => {
    await insertTestData()
    const forms = await Model.select(Model._keys.created, Model._keys.order)
      .orderBy(Model._keys.created, 'asc', 'date')
      .get()

    expect(forms[0].order).toBe(3)
  })

  it('orderBy() should order by Dates without Select()', async () => {
    await insertTestData()
    const forms = await Model.orderBy(Model._keys.created, 'asc', 'date').get()

    expect(forms[0].order).toBe(3)
  })

  it('limit() should limit the amount of results', async () => {
    await insertTestData()
    const forms = await Model.select(Model._keys.created, Model._keys.order)
      .orderBy(Model._keys.created, 'asc', 'date')
      .limit(2)
      .get()

    expect(forms.length).toBe(2)
  })

  it('offset() should start at the given position', async () => {
    await insertTestData()
    const forms = await Model.select(Model._keys.created, Model._keys.order)
      .offset(1)
      .limit(1)
      .get()

    expect(forms.length).toBe(1)
  })

  it('where() should filter the data', async () => {
    await insertTestData()
    const forms = await Model.where(Model._keys.nestedTest.c, '>=', 3).get()

    forms.forEach(form => {
      expect(form.nestedTest.c >= 3).toBe(true)
    })
  })

  it('andWhere() should filter the data', async () => {
    const forms = await Model.where(Model._keys.nestedTest.c, '>=', 3)
      .andWhere(Model._keys.order, '=', 2)
      .limit(1)
      .get()
    expect(forms.length).toBe(1)
    expect(forms[0].order).toBe(2)
  })

  it('first() should take the first result from data', async () => {
    const form = await Model.select(
      Model._keys.order,
      Model._keys.created,
      Model._keys.nestedTest.c
    )
      .where(Model._keys.nestedTest.c, '>=', 3)
      .first()

    expect(typeof form.order).toBe('number')
  })

  it('clear() should remove all records from the Model', async () => {
    await Model.clear({ sure: true })

    const forms = await Model.all()

    expect(forms.length).toBe(0)
  })

  /*
  it('orWhere() should filter the data', async () => {
    const forms = await Model.where(Model._keys.nestedTest.c, '>=', 3)
      .orWhere(Model._keys.order, '=', 2)
      .limit(1)
      .get()
    expect(forms.length).toBe(1)
    expect(forms[0].order).toBe(1)
  })
  */
}
